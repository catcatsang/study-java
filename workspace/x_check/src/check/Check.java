package check;

import java.util.ArrayList;
import java.util.Optional;

public class Check {
   
   public static void main(String[] args) {
//      출력 메소드: 개발자 위한 도구
//      변수: 저장공간(자료구조)
//      연산자: 최단산쉬관리삼대
//      삼항 연산자: 조건식이 1개만 있을 때 사용
//      제어문: 조건문(if문, switch문), 반복문(for, while, do~while)
//      배열: 시작주소, 저장공간 나열
//      메소드: 이름 뒤에 소괄호, 저장공간, 재사용, 소스코드 간결화
//      클래스: 반, 타입이다, 주어이다
//      생성자: 1. 메모리 할당 후 주소 리턴, 2. 초기화, 오버 로딩, alt + shift + s, o
//      기본 생성자: 매개변수가 없다.
//      객체화: 추상적인 개념을 구체화하는 작업, 객체(instanace variable), .
//      this: 접근한 객체
//      상속: extends, 부모는 자식 타입이다(X), 자식은 부모 타입이다.
//      부모의 필드는 자식의 필드다(O), 자식 생성자 호출 시 먼저 부모 생성자가 호출된다.
//      자식에서 부모 필드 접근시 this가 아닌 super로 접근한다.
//      자식 생성자에서 부모의 초기화 생성자를 호출할 때에는 super()를 사용한다.
//      반드시 기본 생성자를 만들어야 한다. 왜냐하면 자식 생성자에서는 기본적으로 부모의 기본 생성자를!!!
//      접근자(public, default, protected, private)
//      private: getter, setter 생성(public)
//      Casting: 부모에 자식을 넣을 수 있다(O, upcasting), 자식에 부모를 넣을 수 있다(X)
//      구현이 전부 되지 않기 때문에. up casting한 객체를 복구할 때 down casting
//      Runnable resource = () -> {};
//      추상 클래스: 강제성, 추상 메소드(abstract), 자식에서 반드시 재정의한다.
//      일반 메소드도 선언 가능
//      인터페이스: 강제성, 추상 메소드밖에 없음. 상수밖에 안됨
//      함수형 인터페이스: 추상 메소드가 1개만 있음. 구현할 때 이름 필요 없음, 람다식
//      람다식은 -> {} 또는 -> 로 구현한다.
//      API: 제발 만들지말고 가져다 쓰자(Appkey, Example, 추가 다운로드 파일, 문해력 필요!)
//      예외처리: try~catch, Exception, RuntimeException, throws, throw
//      Object(equals, toString, hashCode)
//      C.F(List, Set, Map), ArrayList, HashSet, HashMap(서버 간 데이터 전달, JSON)
      
//      여러 개는 ArrayList에 담자!
//      한 개는 Optional에 담자!
//      NPE 발생은 개발자에게 최악의 상황!
//      Optional.ofNullable(null).orElseThrow()
//      ArrayList<String> datas = new ArrayList<String>();
//      datas.forEach((data) -> System.out.println(data));
//      datas.forEach(System.out::println);
   }
}











