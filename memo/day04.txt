상속(Inheritance)
   1. 기존에 선언된 클래스의 필드를 다른 클래스의 필드로 사용하고자 할 때
   2. 여러 클래스 선언 시 필드가 겹치면 공통 필드로 묶고자 할 때

상속 문법
   class A {
      A 필드
   }

   class B extends A{
      A, B 필드
   }

A: 부모 클래스, 상위 클래스, 슈퍼 클래스, 기반 클래스
B: 자식 클래스, 하위 클래스, 서브 클래스, 파생 클래스


super(): 부모 생성자
   자식 클래스 타입의 객체는 부모 필드에 접근할 수 있다.
   하지만 자식 생성자만 호출하기 때문에, 자식 필드만 메모리에 할당 된다.
   그렇기 때문에 B 타입의 객체로 A 필드인 부모 필드에 접근할 수 없어야 정상이다.
   사실 자식 생성자에서 항상 부모 생성자를 호출하기 때문에 자식 생성자 호출 시
   부모와 자식 필드 모두 메모리에 할당된다. 이 때, 부모 생성자를 호출하는 방법은
   super()를 사용하는 것이다. 만약 super()를 작성하지 않더라도 컴파일러가 자동으로 작성해 준다.
   만약 직접 super()를 작성한다면 부모 생성자가 먼저 호출되어야 하기 때문에
   영역의 최상단에 작성해야 한다.

다형성(Polymorphism)
   1. 오버로딩
   2. 오버라이딩(Overriding)
      부모 필드에서 선언한 메소드를 자식 필드에서 수정하고자 할 때 재정의 한다.
      같은 이름의 메소드로 선언하면, 자식 객체로 접근했을 때 가까운 곳에서 찾기 때문에
      자식 필드에서 재정의된 메소드가 사용된다.
      이 때 부모의 메소드를 사용하고 싶다면, 재정의한 메소드 안에서 super로 접근할 수 있다.

===========================================================================================
Casting 
	
	구현되지 않은 메소드가 있다면 메모리에 올릴 수 업ㅅ다.

	User user,
	
	1. up casting
			자식 값을 부모 타입으로 형변환
		
			부모 객체 = new 자식생성자();

		
	2. dow casting

			up casting 된 객체를 다시 자식 타입으로형변환
			
			(자식 클래스)up casting된 객체

			(double)
			
	부모 값을 자식 타입으로 형변환 시 오류 발생.


Casting을 잘 사용하는 방법
	모든 자식들을 하나의 타입으로 묶을 때 up casting을 진행한다.
	전달받은 자식 객체가 어떤 타입인지 검사한 뒤 해당 타입으로 down casting을 진행한다.
	즉, 묶어서 하나의 타입으로 받고, 다시 원래 타입으로 복구하자!

접근 권한 제어자(접근자)
	1.default : 다른 패키지에서 접근불가.
	
	2.public : 모든 곳에서 접근 가능

	3.protected : 다른 패키지에서 접근 불가, 자식은 가능
	4.private : 다른 클래스에서 접근 불가







